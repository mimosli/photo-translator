<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Photo Translator</title>
</head>
<body style="margin:0;background:#0b121a;color:#e8eef5;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial">
<main class="container" style="max-width:920px;margin:0 auto;padding:clamp(16px,4vw,32px)">

  <!-- Welcome / explanation -->
  <section class="card" style="background:#0f1720;color:#e8eef5;border-radius:18px;padding:clamp(16px,3.5vw,28px);border:1px solid rgba(255,255,255,.06);box-shadow:0 10px 30px rgba(0,0,0,.35)">
    <h1 style="margin:0 0 10px;font-size:clamp(22px,5.5vw,34px)">
      Welcome to my helper technology for ‚Äúmy rollercoaster life‚Äù.
      This will help you get the fullest experience of this three-language masterpiece. üìö
    </h1>
    <p style="color:#a9b6c7;line-height:1.55">
      Snap a photo of your poetry and upload it securely. On your smartphone,
      ‚ÄúUse camera‚Äù opens the camera directly (if your browser allows it).
    </p>
    <p style="color:#a9b6c7;line-height:1.55">
      We automatically keep photos under the size limit for faster, safer uploads.
    </p>
  </section>

  <!-- Capture / upload -->
  <section class="card" style="margin-top:16px;background:#0f1720;color:#e8eef5;border-radius:18px;padding:clamp(16px,3.5vw,28px);border:1px solid rgba(255,255,255,.06);box-shadow:0 10px 30px rgba(0,0,0,.35)">
    <h2 style="margin:0 0 10px;font-size:clamp(18px,4.5vw,24px)">Take a photo or upload an image</h2>
    <p class="helper" style="color:#a9b6c7">
      Max size <strong id="limit-label">‚Ä¶</strong>. We will resize if needed.
    </p>

    <div style="display:flex;gap:12px;flex-wrap:wrap;margin:10px 0">
      <label for="cameraInput"
             style="display:inline-flex;align-items:center;gap:10px;padding:10px 12px;border-radius:12px;background:#14212f;border:1px dashed rgba(255,255,255,.12);cursor:pointer">
        üì∑ Use camera
      </label>
      <input id="cameraInput" type="file" accept="image/*" capture="environment" style="display:none" />

      <label for="fileInput"
             style="display:inline-flex;align-items:center;gap:10px;padding:10px 12px;border-radius:12px;background:#14212f;border:1px dashed rgba(255,255,255,.12);cursor:pointer">
        üñºÔ∏è Choose from photos
      </label>
      <input id="fileInput" type="file" accept="image/*" style="display:none" />
    </div>

    <!-- Actions -->
    <div style="display:flex;gap:12px;flex-wrap:wrap;margin-top:14px">
      <button id="uploadBtn" disabled
              style="padding:12px 16px;border-radius:12px;border:0;background:#46a1ff;color:#05121d;font-weight:700;cursor:pointer">
        Upload (save only)
      </button>
      <button id="translateBtn" disabled
              style="padding:12px 16px;border-radius:12px;border:0;background:#29cc7a;color:#05121d;font-weight:700;cursor:pointer">
        Translate now
      </button>
      <button id="clearBtn" disabled
              style="padding:12px 16px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:#1a2633;color:#e8eef5;cursor:pointer">
        Clear
      </button>
    </div>

    <div id="supportNote" style="color:#a9b6c7;font-size:13px;margin:10px 0 8px"></div>
    <div id="preview" style="margin-top:12px;display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:10px"></div>
    <div id="status" role="status" style="margin-top:10px;color:#a9b6c7"></div>
  </section>
</main>

<script>
  // ---- Client config (defaults; server overrides below) ----
  const CONFIG = {
    MAX_BYTES: 3 * 1024 * 1024,
    MAX_DIMENSION: 2200,
    JPEG_QUALITY_START: 0.88,
    JPEG_QUALITY_FLOOR: 0.6,
    API_CONFIG_URL: "{{ url_for('api_config') }}",
    UPLOAD_URL: "{{ url_for('api_upload') }}",           // expects field "file"
    TRANSLATE_URL: "{{ url_for('translate_image') }}",   // expects field "image"
    FIELD_NAME: "file"
  };

  // Hydrate limits from server so UI matches backend policy
  (async function hydrate(){
    try{
      const r = await fetch(CONFIG.API_CONFIG_URL);
      if(r.ok){
        const j = await r.json();
        if(typeof j.maxBytes === "number") CONFIG.MAX_BYTES = j.maxBytes;
        if(typeof j.maxDimension === "number") CONFIG.MAX_DIMENSION = j.maxDimension;
      }
    }catch(_){}
    document.getElementById("limit-label").textContent =
      (CONFIG.MAX_BYTES/1024/1024).toFixed(0) + " MB";
  })();

  const dqs = s => document.querySelector(s);
  const statusEl     = dqs("#status");
  const previewEl    = dqs("#preview");
  const uploadBtn    = dqs("#uploadBtn");
  const translateBtn = dqs("#translateBtn");
  const clearBtn     = dqs("#clearBtn");
  const inputs       = [dqs("#cameraInput"), dqs("#fileInput")];

  // Small UX helper
  (function note(){
    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    dqs("#supportNote").textContent = isMobile
      ? "Tip: allow camera permissions to open the camera directly."
      : "On desktop, camera capture may open a file dialog.";
  })();

  let processedBlob = null, processedName = null;

  // Input handlers
  inputs.forEach(input => {
    input.addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      resetUI();
      try{
        const result = await prepareImage(file);
        processedBlob = result.blob;
        processedName = result.name;
        renderPreview(URL.createObjectURL(processedBlob), processedBlob.size);
        ok(`Ready (${fmt(processedBlob.size)}).`);
        uploadBtn.disabled = false;
        translateBtn.disabled = false;
        clearBtn.disabled = false;
      }catch(err){
        errf(err.message || "Failed to process image.");
      }
    });
  });

  // Clear
  clearBtn.addEventListener("click", () => resetUI(true));

  // Upload (save only)
  uploadBtn.addEventListener("click", async () => {
    if(!processedBlob) return;
    uploadBtn.disabled = true;
    statusEl.style.color = "#a9b6c7";
    statusEl.textContent = "Uploading‚Ä¶";
    try{
      const form = new FormData();
      form.append(CONFIG.FIELD_NAME, processedBlob, processedName || "upload.jpg");
      const res  = await fetch(CONFIG.UPLOAD_URL, { method:"POST", body: form });
      const data = await res.json().catch(()=>null);
      if(!res.ok) throw new Error((data && data.error) || `Upload failed (${res.status}).`);
      ok("Upload complete ‚úÖ");
      // If you want to show the saved image URL:
      // console.log("Saved at", data.url);
    }catch(err){
      errf(err.message || "Upload failed.");
    }finally{
      uploadBtn.disabled = false;
    }
  });

  // Translate now ‚Üí posts to /translate with field "image", then renders returned HTML
  translateBtn.addEventListener("click", async () => {
    if(!processedBlob) return;
    translateBtn.disabled = true;
    statusEl.style.color = "#a9b6c7";
    statusEl.textContent = "Translating‚Ä¶";
    try{
      const form = new FormData();
      form.append("image", processedBlob, processedName || "photo.jpg"); // your /translate expects 'image'
      const res  = await fetch(CONFIG.TRANSLATE_URL, { method:"POST", body: form });
      const ct   = res.headers.get("content-type") || "";
      const body = await res.text();
      if(!res.ok) throw new Error(`Translate failed (${res.status}).`);
      if(ct.includes("text/html")){
        document.open(); document.write(body); document.close();
      }else{
        ok("Translated.");
        console.log(body);
      }
    }catch(err){
      errf(err.message || "Translation failed.");
      translateBtn.disabled = false;
    }
  });

  // ---------- Helpers ----------

  function resetUI(full){
    statusEl.textContent = "";
    statusEl.style.color = "#a9b6c7";
    previewEl.innerHTML = "";
    uploadBtn.disabled = true;
    translateBtn.disabled = true;
    clearBtn.disabled = true;
    if(full){
      inputs.forEach(i => i.value = "");
      processedBlob = null; processedName = null;
    }
  }

  function renderPreview(src, size){
    const wrap = document.createElement("div");
    wrap.style = "position:relative;border-radius:12px;overflow:hidden;background:#0a121a;border:1px solid rgba(255,255,255,.08)";
    const img = new Image();
    img.src = src; img.alt = "Preview";
    img.style = "width:100%;height:160px;object-fit:cover;display:block";
    const badge = document.createElement("div");
    badge.textContent = fmt(size);
    badge.style = "position:absolute;top:8px;left:8px;background:#0b1926;color:#a9b6c7;font-size:11px;padding:4px 6px;border-radius:8px;border:1px solid rgba(255,255,255,.12)";
    wrap.appendChild(img); wrap.appendChild(badge); previewEl.appendChild(wrap);
  }

  function ok(m){ statusEl.style.color = "#29cc7a"; statusEl.textContent = m; }
  function errf(m){ statusEl.style.color = "#ff6b6b"; statusEl.textContent = m; }

  // Turn File ‚Üí ImageBitmap (with fallback for browsers without createImageBitmap)
  async function fileToBitmap(file){
    if("createImageBitmap" in window){
      try { return await createImageBitmap(file); } catch {}
    }
    // Fallback: decode via <img>
    const dataUrl = await fileToDataURL(file);
    return await imgToBitmap(dataUrl);
  }
  function fileToDataURL(file){
    return new Promise((res, rej) => {
      const fr = new FileReader();
      fr.onload = () => res(fr.result);
      fr.onerror = () => rej(new Error("Could not read image."));
      fr.readAsDataURL(file);
    });
  }
  function imgToBitmap(src){
    return new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => {
        const c = document.createElement("canvas");
        c.width = img.naturalWidth; c.height = img.naturalHeight;
        const ctx = c.getContext("2d", { alpha:false });
        ctx.drawImage(img, 0, 0);
        // CanvasRenderingContext2D path: return a bitmap-like object
        res({ width: c.width, height: c.height, _canvas: c });
      };
      img.onerror = () => rej(new Error("Could not decode image."));
      img.src = src;
    });
  }

  // Resize into a bounding box (keeps aspect ratio)
  function drawToMaxBox(bitmap, max){
    let width = bitmap.width, height = bitmap.height;
    if(width > max || height > max){
      const ratio = width / height;
      if(width >= height){ width = max; height = Math.round(max / ratio); }
      else { height = max; width = Math.round(max * ratio); }
    }
    const c = document.createElement("canvas");
    c.width = width; c.height = height;
    const ctx = c.getContext("2d", { alpha:false });
    // If bitmap came from our fallback, it has _canvas; draw that.
    if(bitmap._canvas){ ctx.drawImage(bitmap._canvas, 0, 0, width, height); }
    else { ctx.drawImage(bitmap, 0, 0, width, height); }
    return { canvas: c };
  }

  // Canvas ‚Üí Blob with broad compatibility
  function canvasToBlob(canvas, type, quality){
    return new Promise((resolve, reject) => {
      if(typeof canvas.toBlob === "function"){
        canvas.toBlob(b => b ? resolve(b) : reject(new Error("Canvas toBlob() failed")), type, quality);
      }else{
        try{
          const dataUrl = canvas.toDataURL(type, quality);
          const bin = atob(dataUrl.split(",")[1]);
          const arr = new Uint8Array(bin.length);
          for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
          resolve(new Blob([arr], { type }));
        }catch(e){ reject(e); }
      }
    });
  }

  function fmt(bytes){
    const u=['B','KB','MB','GB']; let i=0,n=bytes;
    while(n>=1024 && i<u.length-1){ n/=1024; i++; }
    return `${n.toFixed(n>=100?0:n>=10?1:2)} ${u[i]}`;
  }
  function safeName(n){
    const base = (n||"image").replace(/\.[a-zA-Z0-9]+$/, "");
    return (base.replace(/[^a-z0-9\-_.]+/ig,'_') || "image") + ".jpg";
  }

  // Main prepare function
  async function prepareImage(file){
    if(!file || !file.type || !file.type.startsWith('image/')){
      throw new Error("Please select an image file.");
    }
    const bitmap = await fileToBitmap(file);
    const { canvas } = drawToMaxBox(bitmap, CONFIG.MAX_DIMENSION);

    // If original is already small enough, keep it
    if(file.size <= CONFIG.MAX_BYTES && Math.max(bitmap.width, bitmap.height) <= CONFIG.MAX_DIMENSION){
      return { blob: file, name: safeName(file.name) };
    }

    let q = CONFIG.JPEG_QUALITY_START;
    let blob = await canvasToBlob(canvas, "image/jpeg", q);
    while(blob.size > CONFIG.MAX_BYTES && q >= CONFIG.JPEG_QUALITY_FLOOR){
      q = Math.max(CONFIG.JPEG_QUALITY_FLOOR, q - 0.06);
      blob = await canvasToBlob(canvas, "image/jpeg", q);
    }
    if(blob.size > CONFIG.MAX_BYTES){
      throw new Error(`Image too large after compression (${fmt(blob.size)}). Try a lower-res photo.`);
    }
    return { blob, name: safeName(file.name) };
  }
</script>
</body>
</html>
